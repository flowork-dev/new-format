<div id="cloak-app-mount" class="fixed inset-0 w-full h-full bg-[#171925] flex flex-col overflow-hidden font-sans">

    <div class="flex-1 flex flex-col md:flex-row h-full overflow-hidden p-2 md:p-4 gap-4">

        <div class="flex-1 bg-black rounded-xl border border-[#3a3962] relative flex flex-col overflow-hidden shadow-2xl order-1">

            <div v-if="!videoSrc" class="absolute inset-0 z-20 flex flex-col items-center justify-center cursor-pointer hover:bg-[#1f2133]/50 transition-colors" @click="triggerUpload">
                <div class="w-20 h-20 bg-[#1f2133] rounded-full flex items-center justify-center mb-4 border border-[#54d7f6]/30 group-hover:border-[#54d7f6] group-hover:scale-110 transition-transform shadow-[0_0_20px_rgba(84,215,246,0.1)]">
                    <i class="mdi mdi-video-plus text-4xl text-[#54d7f6]"></i>
                </div>
                <h3 class="orbitron text-white text-lg font-bold tracking-widest">VIDEO CLOAK INPUT</h3>
                <p class="text-gray-500 text-xs mono mt-2 opacity-70">MP4 / WEBM / MOV</p>
                <input type="file" ref="fileInput" class="hidden" accept="video/*" @change="handleFile">
            </div>

            <div class="absolute inset-0 w-full h-full flex items-center justify-center bg-black">
                <video ref="videoRef" class="absolute top-0 left-0 w-[1px] h-[1px] opacity-0 pointer-events-none" crossorigin="anonymous" playsinline></video>
                <canvas ref="canvasRef" class="max-w-full max-h-full object-contain"></canvas>
            </div>

            <div v-if="isProcessing" class="absolute inset-0 z-30 bg-black/90 flex flex-col items-center justify-center backdrop-blur-sm">
                <div class="relative w-24 h-24 mb-6">
                    <div class="absolute inset-0 border-4 border-[#3a3962] rounded-full"></div>
                    <div class="absolute inset-0 border-4 border-t-[#54d7f6] rounded-full animate-spin"></div>
                    <div class="absolute inset-0 flex items-center justify-center">
                        <span class="orbitron font-bold text-white text-xl">{{ progressPercent }}%</span>
                    </div>
                </div>
                <div class="text-[#54d7f6] font-bold orbitron text-lg animate-pulse tracking-[0.2em]">RENDERING CLOAK...</div>
                <div class="text-gray-400 text-xs mono mt-3 bg-[#1f2133] px-3 py-1 rounded border border-[#3a3962]">{{ statusText }}</div>
            </div>
        </div>

        <div class="w-full md:w-96 h-[50vh] md:h-full shrink-0 flex flex-col gap-3 order-2 overflow-y-auto custom-scrollbar">

            <div class="bg-[#1f2133] p-4 rounded-xl border border-[#3a3962]">
                <h2 class="text-white font-bold orbitron flex items-center gap-2">
                    <i class="mdi mdi-cogs text-[#54d7f6]"></i> CONFIGURATION
                </h2>
                <div class="text-[10px] text-gray-500 mono mt-1 flex justify-between">
                    <span>MODE: SWAP-SPLIT + AUTO-FILL</span>
                    <span v-if="videoSrc" class="text-green-400">READY</span>
                </div>
            </div>

            <div class="bg-[#1f2133] p-4 rounded-xl border border-[#3a3962] space-y-4">
                <div class="flex justify-between items-center border-b border-gray-700 pb-2 mb-2">
                    <span class="text-[10px] font-bold text-white orbitron">AUDIO JAMMER MIXER</span>
                    <button @click="toggleAudioPreview" :disabled="!videoSrc || isProcessing" :class="isPreviewing ? 'text-red-400 animate-pulse' : 'text-[#54d7f6]'" class="text-[10px] font-bold hover:underline disabled:opacity-50">
                        <i :class="isPreviewing ? 'mdi mdi-stop' : 'mdi mdi-play'"></i> {{ isPreviewing ? 'STOP PREVIEW' : 'TEST AUDIO' }}
                    </button>
                </div>

                <div>
                    <label class="block text-[9px] font-mono text-green-400 mb-1 flex justify-between">
                        <span>ORIGINAL VOICE</span> <span>{{ volOriginal }}%</span>
                    </label>
                    <input type="range" v-model="volOriginal" @input="updateAudioParams" min="0" max="150" class="w-full h-1.5 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-green-500">
                </div>

                <div>
                    <label class="block text-[9px] font-mono text-[#54d7f6] mb-1 flex justify-between">
                        <span>JAMMER VOICE (AUTO-FILL)</span> <span>{{ volJammer }}%</span>
                    </label>
                    <input type="range" v-model="volJammer" @input="updateAudioParams" min="0" max="150" class="w-full h-1.5 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-[#54d7f6]">
                </div>
            </div>

            <div class="bg-[#1f2133] p-4 rounded-xl border border-[#3a3962] space-y-4">
                <div class="text-[10px] font-bold text-white orbitron border-b border-gray-700 pb-2">VISUAL EVASION STRATEGY</div>

                <div class="flex items-center justify-between">
                    <span class="text-[10px] text-gray-400">Micro-Zoom & Pan</span>
                    <span class="text-[10px] text-[#54d7f6]">ACTIVE</span>
                </div>
                <div class="flex items-center justify-between">
                    <span class="text-[10px] text-gray-400">Color Matrix Shift</span>
                    <span class="text-[10px] text-[#54d7f6]">ACTIVE</span>
                </div>

                <div class="flex items-center justify-between">
                    <span class="text-[10px] text-gray-400">Mirror Mode (Flip)</span>
                    <button @click="isMirrored = !isMirrored" :class="isMirrored ? 'bg-[#54d7f6] text-black' : 'bg-gray-700 text-gray-400'" class="px-2 py-0.5 rounded text-[9px] font-bold transition-colors">
                        {{ isMirrored ? 'ON' : 'OFF' }}
                    </button>
                </div>
            </div>

            <div class="bg-[#1f2133] p-4 rounded-xl border border-[#3a3962] mt-auto">
                <button @click="startProcess" :disabled="!videoSrc || isProcessing"
                    class="w-full py-4 bg-gradient-to-r from-[#54d7f6] to-[#00aaff] hover:from-[#4bc3e0] hover:to-[#0099eb] disabled:from-gray-700 disabled:to-gray-800 disabled:text-gray-500 text-[#171925] font-black rounded-lg orbitron tracking-widest transition-all shadow-[0_0_20px_rgba(84,215,246,0.2)] disabled:shadow-none transform active:scale-95 disabled:scale-100 flex items-center justify-center gap-2">
                    <span v-if="!isProcessing"><i class="mdi mdi-shield-check text-lg"></i> RENDER & CLOAK</span>
                    <span v-else><i class="mdi mdi-loading mdi-spin"></i> PROCESSING...</span>
                </button>

                <div v-if="downloadUrl" class="mt-3 animate__animated animate__fadeIn">
                    <a :href="downloadUrl" :download="outputName" class="block w-full py-3 bg-green-600 hover:bg-green-500 text-white font-bold rounded text-xs tracking-widest text-center transition">
                        <i class="mdi mdi-download"></i> DOWNLOAD RESULT
                    </a>
                </div>
            </div>

        </div>
    </div>
</div>

<script>
    window.initCloakApp = function() {
        const { createApp, ref, nextTick, onBeforeUnmount } = Vue;

        return createApp({
            setup() {
                // UI STATE
                const videoSrc = ref(null);
                const isProcessing = ref(false);
                const isPreviewing = ref(false);
                const progressPercent = ref(0);
                const statusText = ref('SYSTEM READY');
                const downloadUrl = ref(null);
                const outputName = ref('');

                // SETTINGS
                const volOriginal = ref(100);
                const volJammer = ref(80);
                const isMirrored = ref(false);

                // REFS
                const fileInput = ref(null);
                const videoRef = ref(null);
                const canvasRef = ref(null);

                // ENGINE VARS
                let audioCtx = null;
                let originalBuffer = null;
                let previewSource = null;
                let animationId = null;
                let mediaRecorder = null;

                const triggerUpload = () => fileInput.value.click();

                const handleFile = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    // Cleanup
                    if (videoSrc.value) URL.revokeObjectURL(videoSrc.value);
                    if (downloadUrl.value) URL.revokeObjectURL(downloadUrl.value);
                    stopAudioPreview();

                    videoSrc.value = URL.createObjectURL(file);
                    outputName.value = `CLOAKED_${Math.floor(Math.random()*10000)}_${file.name}`;

                    nextTick(async () => {
                        const vid = videoRef.value;
                        const cvs = canvasRef.value;
                        vid.src = videoSrc.value;

                        // Load Audio Buffer
                        statusText.value = "ANALYZING AUDIO SPECTRUM...";
                        const arrayBuffer = await file.arrayBuffer();
                        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        originalBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                        statusText.value = "AUDIO LOADED & READY";

                        vid.onloadedmetadata = () => {
                            cvs.width = vid.videoWidth;
                            cvs.height = vid.videoHeight;
                            const ctx = cvs.getContext('2d');
                            ctx.drawImage(vid, 0, 0); // Draw first frame
                        };
                    });
                };

                // --- AUDIO ENGINE: SWAP-SPLIT + AUTO-FILL ---
                const processAudioTrack = async (duration, isPreview = false) => {
                    const sampleRate = originalBuffer.sampleRate;
                    // Kalau preview, potong durasi biar enteng (5 detik)
                    const renderDuration = isPreview ? Math.min(5, duration) : duration;
                    const frameCount = Math.floor(renderDuration * sampleRate);

                    const offlineCtx = new OfflineAudioContext(originalBuffer.numberOfChannels, frameCount, sampleRate);

                    // LAYER 1: ORIGINAL (Gated/Volumed)
                    const source = offlineCtx.createBufferSource();
                    // Copy buffer sesuai durasi
                    const tempBuf = offlineCtx.createBuffer(originalBuffer.numberOfChannels, frameCount, sampleRate);
                    for(let c=0; c<originalBuffer.numberOfChannels; c++){
                        tempBuf.copyToChannel(originalBuffer.getChannelData(c).slice(0, frameCount), c);
                    }
                    source.buffer = tempBuf;

                    const sourceGain = offlineCtx.createGain();
                    sourceGain.gain.value = volOriginal.value / 100;
                    source.connect(sourceGain);
                    sourceGain.connect(offlineCtx.destination);

                    // LAYER 2: JAMMER (SWAP SPLIT + AUTO-FILL)
                    const jammerBuffer = offlineCtx.createBuffer(originalBuffer.numberOfChannels, frameCount, sampleRate);
                    const splitPoint = Math.floor(frameCount / 2);

                    for (let ch = 0; ch < originalBuffer.numberOfChannels; ch++) {
                        const inputData = tempBuf.getChannelData(ch);
                        const outputData = jammerBuffer.getChannelData(ch);
                        let envelope = 0;

                        for(let i = 0; i < frameCount; i++) {
                            // A. SWAP LOGIC
                            let srcIdx;
                            if (i < (frameCount - splitPoint)) srcIdx = splitPoint + i;
                            else srcIdx = i - (frameCount - splitPoint);

                            let rawSample = (srcIdx < inputData.length) ? inputData[srcIdx] : 0;

                            // B. AUTO-FILL (INVERTED GATING)
                            const absInput = Math.abs(inputData[i]);
                            envelope = envelope * 0.999 + absInput * 0.001; // Smooth follower

                            // Kalau hening (envelope < 0.1), boost jammer
                            let silenceBoost = 1.0;
                            if(envelope < 0.05) {
                                silenceBoost = 1.0 + ((0.05 - envelope) * 20.0); // Boost up to 2x
                            }

                            outputData[i] = rawSample * silenceBoost;
                        }
                    }

                    const jammerSource = offlineCtx.createBufferSource();
                    jammerSource.buffer = jammerBuffer;

                    const jammerGain = offlineCtx.createGain();
                    jammerGain.gain.value = volJammer.value / 100;

                    jammerSource.connect(jammerGain);
                    jammerGain.connect(offlineCtx.destination);

                    // Render
                    source.start();
                    jammerSource.start();
                    return await offlineCtx.startRendering();
                };

                // --- AUDIO PREVIEW ---
                const toggleAudioPreview = async () => {
                    if (isPreviewing.value) {
                        stopAudioPreview();
                    } else {
                        if (!originalBuffer) return;
                        isPreviewing.value = true;

                        // Render 5 detik sampel
                        const renderedBuffer = await processAudioTrack(originalBuffer.duration, true);

                        // Play Loop
                        const loopCtx = new (window.AudioContext || window.webkitAudioContext)();
                        previewSource = loopCtx.createBufferSource();
                        previewSource.buffer = renderedBuffer;
                        previewSource.loop = true;
                        previewSource.connect(loopCtx.destination);
                        previewSource.start();
                    }
                };

                const stopAudioPreview = () => {
                    if (previewSource) {
                        try { previewSource.stop(); } catch(e){}
                        previewSource = null;
                    }
                    isPreviewing.value = false;
                };

                const updateAudioParams = () => {
                    // Real-time update pas preview (Debounce dikit biar ga berat)
                    if(isPreviewing.value) {
                        stopAudioPreview();
                        setTimeout(toggleAudioPreview, 100);
                    }
                };

                // --- VIDEO PROCESSOR ---
                const startProcess = async () => {
                    if (!videoSrc.value) return;
                    isProcessing.value = true;
                    stopAudioPreview();
                    statusText.value = "INITIALIZING ENGINE...";

                    const vid = videoRef.value;
                    const cvs = canvasRef.value;
                    const ctx = cvs.getContext('2d');

                    // 1. RENDER AUDIO LENGKAP
                    statusText.value = "PROCESSING AUDIO JAMMER...";
                    const finalAudioBuffer = await processAudioTrack(vid.duration, false);

                    // Setup Stream Destination buat Audio
                    const destAudioNode = audioCtx.createMediaStreamDestination();
                    const finalAudioSource = audioCtx.createBufferSource();
                    finalAudioSource.buffer = finalAudioBuffer;
                    finalAudioSource.connect(destAudioNode);

                    // 2. VIDEO CANVAS STREAM
                    const canvasStream = cvs.captureStream(30); // 30 FPS target

                    // Gabung Stream (Video Canvas + Processed Audio)
                    const combinedStream = new MediaStream([
                        ...canvasStream.getVideoTracks(),
                        ...destAudioNode.stream.getAudioTracks()
                    ]);

                    // Setup Recorder
                    let mimeType = 'video/webm; codecs=vp9'; // Chrome standard
                    if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/mp4'; // Fallback

                    mediaRecorder = new MediaRecorder(combinedStream, {
                        mimeType,
                        videoBitsPerSecond: 8000000 // 8 Mbps High Quality
                    });

                    const chunks = [];
                    mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: mimeType });
                        downloadUrl.value = URL.createObjectURL(blob);
                        isProcessing.value = false;
                        statusText.value = "COMPLETED";
                        vid.pause();
                        vid.currentTime = 0;
                        cancelAnimationFrame(animationId);
                    };

                    // 3. START RENDERING LOOP
                    statusText.value = "RENDERING VISUAL CLOAK...";
                    vid.currentTime = 0;
                    vid.playbackRate = 1.0; // Play normal speed for recording sync
                    vid.muted = true; // Mute video element (audio comes from buffer)

                    await vid.play();
                    finalAudioSource.start(); // Start audio sync
                    mediaRecorder.start();

                    const drawFrame = () => {
                        if (vid.paused || vid.ended) {
                            if (mediaRecorder.state === 'recording') mediaRecorder.stop();
                            return;
                        }

                        // Progress Bar
                        progressPercent.value = Math.floor((vid.currentTime / vid.duration) * 100);

                        // Visual Strategy Logic
                        const w = cvs.width;
                        const h = cvs.height;

                        ctx.clearRect(0, 0, w, h);

                        // A. MICRO-ZOOM (Breathing)
                        const zoomSpeed = 0.05;
                        const zoomAmount = 0.02; // 2% zoom in-out
                        const scale = 1.0 + (Math.sin(vid.currentTime * zoomSpeed) * zoomAmount);

                        // B. PANNING (Geser dikit koordinatnya)
                        const panX = Math.cos(vid.currentTime * 0.1) * (w * 0.01);
                        const panY = Math.sin(vid.currentTime * 0.1) * (h * 0.01);

                        const dw = w * scale;
                        const dh = h * scale;
                        const dx = ((w - dw) / 2) + panX;
                        const dy = ((h - dh) / 2) + panY;

                        ctx.save();

                        // C. MIRRORING (Optional)
                        if(isMirrored.value) {
                            ctx.translate(w, 0);
                            ctx.scale(-1, 1);
                        }

                        ctx.drawImage(vid, dx, dy, dw, dh);
                        ctx.restore();

                        // D. COLOR SHIFT (Invisible Tint)
                        // Ubah nuansa warna sangat halus
                        ctx.globalCompositeOperation = 'overlay';
                        ctx.fillStyle = `rgba(${10 + Math.sin(vid.currentTime)*10}, 0, ${10 + Math.cos(vid.currentTime)*10}, 0.05)`;
                        ctx.fillRect(0, 0, w, h);
                        ctx.globalCompositeOperation = 'source-over';

                        // E. SCANLINE NOISE
                        if (Math.random() > 0.8) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                            const lineY = Math.random() * h;
                            ctx.fillRect(0, lineY, w, 2);
                        }

                        animationId = requestAnimationFrame(drawFrame);
                    };
                    drawFrame();
                };

                return {
                    videoSrc, isProcessing, isPreviewing, progressPercent, statusText, downloadUrl, outputName,
                    volOriginal, volJammer, isMirrored,
                    fileInput, videoRef, canvasRef,
                    triggerUpload, handleFile, startProcess,
                    toggleAudioPreview, updateAudioParams
                };
            }
        }).mount('#cloak-app-mount');
    }
</script>